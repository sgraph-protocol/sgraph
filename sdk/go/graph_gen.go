// Code generated by anchorgen for program graph v0.1.0. DO NOT EDIT
package solana

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/near/borsh-go"
	"github.com/portto/solana-go-sdk/common"
	"github.com/portto/solana-go-sdk/types"
)

var GraphProgramAddress = common.PublicKeyFromString("graph8zS8zjLVJHdiSvP7S9PP7hNJpnHdbnJLR81FMg")

// removes unused errors
var (
	_ = errors.New
	_ = fmt.Print
	_ = bytes.Equal
	_ = borsh.Serialize
	_ = common.PublicKey{}
	_ = types.Instruction{}
)

var (
	InitializeTreeInstructionDiscriminator = [8]uint8{0xd3, 0xe7, 0xb5, 0xae, 0x28, 0x4d, 0xe3, 0x33}

	InitializeProviderInstructionDiscriminator = [8]uint8{0xb5, 0x67, 0xe1, 0xe, 0xd6, 0xd2, 0xa1, 0xee}

	AddRelationInstructionDiscriminator = [8]uint8{0x69, 0x93, 0x93, 0xd6, 0xfc, 0x85, 0x9b, 0xd2}
)

type InitializeTreeAccounts struct {
	Tree           common.PublicKey // 1
	TreeController common.PublicKey // 2
	Authority      common.PublicKey // 3
	Payer          common.PublicKey // 4
	AcProgram      common.PublicKey // 5
	NoopProgram    common.PublicKey // 6
}

// InitializeTreeInstruction creates initializeTree instruction
func InitializeTreeInstruction(accounts InitializeTreeAccounts) (types.Instruction, error) {
	inst := struct {
		desc [8]byte

		// no args

	}{
		desc: InitializeTreeInstructionDiscriminator,
	}
	data, err := borsh.Serialize(inst)
	if err != nil {
		return types.Instruction{}, err
	}

	return types.Instruction{
		ProgramID: GraphProgramAddress,
		Accounts: []types.AccountMeta{
			{PubKey: accounts.Tree, IsSigner: false, IsWritable: true},           // 1
			{PubKey: accounts.TreeController, IsSigner: false, IsWritable: true}, // 2
			{PubKey: accounts.Authority, IsSigner: true, IsWritable: false},      // 3
			{PubKey: accounts.Payer, IsSigner: true, IsWritable: true},           // 4
			{PubKey: accounts.AcProgram, IsSigner: false, IsWritable: false},     // 5
			{PubKey: accounts.NoopProgram, IsSigner: false, IsWritable: false},   // 6
			{PubKey: common.SystemProgramID, IsSigner: false, IsWritable: false}, // 7

		},
		Data: data,
	}, nil
}

type InitializeProviderAccounts struct {
	Provider common.PublicKey // 1
	Payer    common.PublicKey // 2
}

// InitializeProviderInstruction creates initializeProvider instruction
func InitializeProviderInstruction(accounts InitializeProviderAccounts, args InitializeProviderParams) (types.Instruction, error) {
	inst := struct {
		desc [8]byte

		args InitializeProviderParams
	}{
		desc: InitializeProviderInstructionDiscriminator,

		args: args,
	}
	data, err := borsh.Serialize(inst)
	if err != nil {
		return types.Instruction{}, err
	}

	return types.Instruction{
		ProgramID: GraphProgramAddress,
		Accounts: []types.AccountMeta{
			{PubKey: accounts.Provider, IsSigner: true, IsWritable: true},        // 1
			{PubKey: accounts.Payer, IsSigner: true, IsWritable: true},           // 2
			{PubKey: common.SystemProgramID, IsSigner: false, IsWritable: false}, // 3

		},
		Data: data,
	}, nil
}

type AddRelationAccounts struct {
	Provider       common.PublicKey // 1
	Authority      common.PublicKey // 2
	Tree           common.PublicKey // 3
	TreeController common.PublicKey // 4
	Payer          common.PublicKey // 5
	AcProgram      common.PublicKey // 6
	NoopProgram    common.PublicKey // 7
}

// AddRelationInstruction creates addRelation instruction
func AddRelationInstruction(accounts AddRelationAccounts, args AddRelationParams) (types.Instruction, error) {
	inst := struct {
		desc [8]byte

		args AddRelationParams
	}{
		desc: AddRelationInstructionDiscriminator,

		args: args,
	}
	data, err := borsh.Serialize(inst)
	if err != nil {
		return types.Instruction{}, err
	}

	return types.Instruction{
		ProgramID: GraphProgramAddress,
		Accounts: []types.AccountMeta{
			{PubKey: accounts.Provider, IsSigner: false, IsWritable: true},        // 1
			{PubKey: accounts.Authority, IsSigner: true, IsWritable: false},       // 2
			{PubKey: accounts.Tree, IsSigner: false, IsWritable: true},            // 3
			{PubKey: accounts.TreeController, IsSigner: false, IsWritable: false}, // 4
			{PubKey: accounts.Payer, IsSigner: true, IsWritable: true},            // 5
			{PubKey: accounts.AcProgram, IsSigner: false, IsWritable: false},      // 6
			{PubKey: accounts.NoopProgram, IsSigner: false, IsWritable: false},    // 7

		},
		Data: data,
	}, nil
}

var (
	ProviderDiscriminator = [8]uint8{0xa4, 0xb4, 0x47, 0x11, 0x4b, 0xd8, 0x50, 0xc3}

	RelationDiscriminator = [8]uint8{0x67, 0x20, 0x49, 0xbd, 0x31, 0x3c, 0x45, 0x8a}

	ControllerDiscriminator = [8]uint8{0xb8, 0x4f, 0xab, 0x0, 0xb7, 0x2b, 0x71, 0x6e}
)

// account Provider
type Provider struct {
	Authority common.PublicKey

	RelationsCount uint64

	Name string

	Website string
}

// ProviderDeserialize checks descriminator and initializes Provider from account data
func ProviderDeserialize(data []byte) (Provider, error) {
	var s struct {
		Discriminant [8]byte
		Provider
	}
	if err := borsh.Deserialize(&s, data); err != nil {
		return Provider{}, err
	}
	if !bytes.Equal(s.Discriminant[:], ProviderDiscriminator[:]) {
		return Provider{}, errors.New("Provider discriminator mismatch")
	}
	return s.Provider, nil
}

// account Relation
type Relation struct {
	From common.PublicKey

	To common.PublicKey

	Provider common.PublicKey

	ConnectedAt int64

	DisconnectedAt *int64

	Extra []byte
}

// RelationDeserialize checks descriminator and initializes Relation from account data
func RelationDeserialize(data []byte) (Relation, error) {
	var s struct {
		Discriminant [8]byte
		Relation
	}
	if err := borsh.Deserialize(&s, data); err != nil {
		return Relation{}, err
	}
	if !bytes.Equal(s.Discriminant[:], RelationDiscriminator[:]) {
		return Relation{}, errors.New("Relation discriminator mismatch")
	}
	return s.Relation, nil
}

// account Controller
type Controller struct {
	Authority common.PublicKey

	Tree common.PublicKey
}

// ControllerDeserialize checks descriminator and initializes Controller from account data
func ControllerDeserialize(data []byte) (Controller, error) {
	var s struct {
		Discriminant [8]byte
		Controller
	}
	if err := borsh.Deserialize(&s, data); err != nil {
		return Controller{}, err
	}
	if !bytes.Equal(s.Discriminant[:], ControllerDiscriminator[:]) {
		return Controller{}, errors.New("Controller discriminator mismatch")
	}
	return s.Controller, nil
}

type InitializeProviderParams struct {
	Authority common.PublicKey

	Name string

	Website string
}

type AddRelationParams struct {
	From common.PublicKey

	To common.PublicKey

	Extra []byte
}

type LeafType borsh.Enum

const (
	LeafTypeUnknown    borsh.Enum = iota
	LeafTypeRelationV1 borsh.Enum = iota
)
