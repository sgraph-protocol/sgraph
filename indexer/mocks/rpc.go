// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/sgraph-protocol/sgraph/indexer/cli"
)

// RpcMock is a mock implementation of main.RPC.
//
//	func TestSomethingThatUsesRPC(t *testing.T) {
//
//		// make and configure a mocked main.RPC
//		mockedRPC := &RpcMock{
//			GetBlocksFunc: func(ctx context.Context, retries uint, blocksIds ...uint64) ([]cli.Block, []int, error) {
//				panic("mock out the GetBlocks method")
//			},
//			GetBlocksWithLimitFunc: func(ctx context.Context, from uint64, limit uint64) ([]uint64, error) {
//				panic("mock out the GetBlocksWithLimit method")
//			},
//			GetLatestBlockFunc: func(ctx context.Context) (uint64, error) {
//				panic("mock out the GetLatestBlock method")
//			},
//		}
//
//		// use mockedRPC in code that requires main.RPC
//		// and then make assertions.
//
//	}
type RpcMock struct {
	// GetBlocksFunc mocks the GetBlocks method.
	GetBlocksFunc func(ctx context.Context, retries uint, blocksIds ...uint64) ([]cli.Block, []int, error)

	// GetBlocksWithLimitFunc mocks the GetBlocksWithLimit method.
	GetBlocksWithLimitFunc func(ctx context.Context, from uint64, limit uint64) ([]uint64, error)

	// GetLatestBlockFunc mocks the GetLatestBlock method.
	GetLatestBlockFunc func(ctx context.Context) (uint64, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetBlocks holds details about calls to the GetBlocks method.
		GetBlocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Retries is the retries argument value.
			Retries uint
			// BlocksIds is the blocksIds argument value.
			BlocksIds []uint64
		}
		// GetBlocksWithLimit holds details about calls to the GetBlocksWithLimit method.
		GetBlocksWithLimit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From uint64
			// Limit is the limit argument value.
			Limit uint64
		}
		// GetLatestBlock holds details about calls to the GetLatestBlock method.
		GetLatestBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetBlocks          sync.RWMutex
	lockGetBlocksWithLimit sync.RWMutex
	lockGetLatestBlock     sync.RWMutex
}

// GetBlocks calls GetBlocksFunc.
func (mock *RpcMock) GetBlocks(ctx context.Context, retries uint, blocksIds ...uint64) ([]cli.Block, []int, error) {
	if mock.GetBlocksFunc == nil {
		panic("RpcMock.GetBlocksFunc: method is nil but RPC.GetBlocks was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Retries   uint
		BlocksIds []uint64
	}{
		Ctx:       ctx,
		Retries:   retries,
		BlocksIds: blocksIds,
	}
	mock.lockGetBlocks.Lock()
	mock.calls.GetBlocks = append(mock.calls.GetBlocks, callInfo)
	mock.lockGetBlocks.Unlock()
	return mock.GetBlocksFunc(ctx, retries, blocksIds...)
}

// GetBlocksCalls gets all the calls that were made to GetBlocks.
// Check the length with:
//
//	len(mockedRPC.GetBlocksCalls())
func (mock *RpcMock) GetBlocksCalls() []struct {
	Ctx       context.Context
	Retries   uint
	BlocksIds []uint64
} {
	var calls []struct {
		Ctx       context.Context
		Retries   uint
		BlocksIds []uint64
	}
	mock.lockGetBlocks.RLock()
	calls = mock.calls.GetBlocks
	mock.lockGetBlocks.RUnlock()
	return calls
}

// GetBlocksWithLimit calls GetBlocksWithLimitFunc.
func (mock *RpcMock) GetBlocksWithLimit(ctx context.Context, from uint64, limit uint64) ([]uint64, error) {
	if mock.GetBlocksWithLimitFunc == nil {
		panic("RpcMock.GetBlocksWithLimitFunc: method is nil but RPC.GetBlocksWithLimit was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		From  uint64
		Limit uint64
	}{
		Ctx:   ctx,
		From:  from,
		Limit: limit,
	}
	mock.lockGetBlocksWithLimit.Lock()
	mock.calls.GetBlocksWithLimit = append(mock.calls.GetBlocksWithLimit, callInfo)
	mock.lockGetBlocksWithLimit.Unlock()
	return mock.GetBlocksWithLimitFunc(ctx, from, limit)
}

// GetBlocksWithLimitCalls gets all the calls that were made to GetBlocksWithLimit.
// Check the length with:
//
//	len(mockedRPC.GetBlocksWithLimitCalls())
func (mock *RpcMock) GetBlocksWithLimitCalls() []struct {
	Ctx   context.Context
	From  uint64
	Limit uint64
} {
	var calls []struct {
		Ctx   context.Context
		From  uint64
		Limit uint64
	}
	mock.lockGetBlocksWithLimit.RLock()
	calls = mock.calls.GetBlocksWithLimit
	mock.lockGetBlocksWithLimit.RUnlock()
	return calls
}

// GetLatestBlock calls GetLatestBlockFunc.
func (mock *RpcMock) GetLatestBlock(ctx context.Context) (uint64, error) {
	if mock.GetLatestBlockFunc == nil {
		panic("RpcMock.GetLatestBlockFunc: method is nil but RPC.GetLatestBlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestBlock.Lock()
	mock.calls.GetLatestBlock = append(mock.calls.GetLatestBlock, callInfo)
	mock.lockGetLatestBlock.Unlock()
	return mock.GetLatestBlockFunc(ctx)
}

// GetLatestBlockCalls gets all the calls that were made to GetLatestBlock.
// Check the length with:
//
//	len(mockedRPC.GetLatestBlockCalls())
func (mock *RpcMock) GetLatestBlockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetLatestBlock.RLock()
	calls = mock.calls.GetLatestBlock
	mock.lockGetLatestBlock.RUnlock()
	return calls
}
